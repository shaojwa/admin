#### paxos 解决场景

消息不可靠的四种可能：丢失，延迟，乱序，重复。

#### 基本机制

采用大多数机制（Majority）来保证2N+1的容错能力。即2N+1个节点的集群中最多允许N个节点出现个故障。

#### 目标

一个后者多个提交者提交提议，对多只让一个提议达成共识（是否包括不对任何提议达成共识？？？）。

# 摘要

paxos算法是为了实现一种能容错的分布式系统，这是一种简单的并且显而易见的分布式算法。核心是共识算法：synod。

# 共识算法

## 问题

假设有一个进程集合，集合中的每个进程都可以提议一个值，一致性算法保证的是，只有一个值被选择。如果没有值被提议，那么没有value被选择。如果有一个值被选择，那么进程应该能学习到这个值。针对共识的安全性需求是：（1）只有一个提议的值可能被选择，并且也只有一个值被选择。（2）一直值只有被确定选择之后，才能被其他进程学习到。

我们不会去指定精确的活性要求，但是我们需要保证某个提议值最终会被选择。并且被选择之后，进程可以学习到。

算法中，进程有三种角色的代理：proposers，accepters 和，learners。一个进程会承担多个角色。

假设一个进程可以通过发送消息与另外一个进程通信。我们采用惯用的异步，非拜占庭模型，在这个模型中：

（1）任何一种觉得以任意的速度操作，可能停止，可能重启。因为所有的角色都可能在一个值被选择之后停止，然后重启。除记住某些信息的角色在失败后重启，否则没有办法实现。

（2） 消息可以的传递用时不确定，也可能乱序，也可能丢失，但是内容不会被损坏。

## 选择一个值

最简单的选择一个值的办法是，只有一个accepter，proposer提议一个值，accepter选择第一个收到的提议的值。尽管简单，但是不满足要求，因为
accepter的故障挂机会导致后续的流程无法继续。（检测到挂了，可以再起一个新的？）

当我们选择另外一个方法，我们采用多个accepter，一个proposer给多个accepter发送提议，如果多个accepter接受这个值，那这个值就被接受，那么多个是几个？大于一半的数量，为什么？因为任何两个多数集合一定至少有一个公共成员。

在不考虑挂机以及消息丢失的情况下，如果我们希望就算只有一个值被提议，这个值也能被接受的话，就有如下要求：

(P1) 一个accepter 必须接受它第一个收到的值。但这会导致一个问题，多个而不同的proposer会提议不同的值，而这些不同的值可能会被不同的accepter接受，而没有任何一个值达到半数。就算是两个值被提议，只要一个accepter挂掉，也有可能导致没有一个值被多数的accepter接受。所以accepter必须允许接受多个提议的值。所以我们必须跟踪每一个可能被接受的提议。用不同的数值标记不同的提议（proposal）

(P2)  如果一个值为v，标号为n的提议被选择（注意），那么所有被选择（注意）的序号大于n的提议的值都必须是v。  
(P2a) 如果一个值为v，标号为n的提议被选择（注意），那么所有被接受（注意）的序号大于n的提议的值都必须是v。  
(P2b) 如果一个值为v，标号为n的提议被选择（注意），那么所有被发布（注意）的序号大于n的提议的值都必须是v。 
