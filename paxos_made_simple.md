# 摘要

paxos算法是为了实现一种能容错的分布式系统，这是一种简单的并且显而易见的分布式算法。核心是共识算法：synod。

# 共识算法

## 问题

假设有一个进程集合，集合中的每个进程都可以提议一个值，一致性算法保证的是，只有一个值被选择。如果没有值被提议，那么没有value被选择。
如果有一个值被选择，那么进程应该能学习到这个值。针对共识的安全性需求是：

* （1）只有一个提议的值可能被选择，并且也只有一个值被选择。
* （2）一直值只有被确定选择之后，才能被其他进程学习到。

我们不会去指定精确的存活要求（不保证某些节点一直都在），但是我们需要保证某个提议值最终会被选择。并且被选择之后，进程可以学习到。
算法中，进程有三种角色的代理：proposers，accepters 和，learners。

注意，在具体实现中，一个进程会承担多个角色。

假设一个进程可以通过发送消息与另外一个进程通信。我们采用惯用的异步，非拜占庭模型，在这个模型中：

（1）进程以任意的速度运行，可能停止，可能重启。因为所有的角色都可能在一个值被选择之后停止，然后重启。 

（2） 消息的延时时不确定，也可能丢失，也可能乱序，可能重复，但是内容不会被损坏。

## 两个阶段

先选择一个值，然后学习到这个值。

## 选择一个值

最简单的选择一个值的办法是，只有一个accepter，proposer提议一个值，accepter选择第一个收到的提议的值。尽管简单，但是不满足要求，因为
accepter的故障挂机会导致后续的流程无法继续。

问题：一个acceptor挂掉之后，可以再起一个，为什么会影响后续的流程是什么，学习值么？检测到挂了，可以再起一个新的，会有什么问题？

我们选择另外一个方法，我们采用多个accepter，一个proposer给多个accepter发送提议，如果多个accepter接受这个值，那这个值就被接受。
比如9个节点，5个接受了值a，5个接受了值b，在一个节点只能接受一个值的前提下，a一定是等于b的。

问题：为什么集合大小要大于一半acceptor的值才被选中，因为这样才可以保证整个集群中只有一个值被选中，不然可能存在多个不同的值被选中。

在不考虑挂机以及消息丢失的情况下，如果我们希望就算只有一个值被提议，这个值也能被接受的话，就有如下要求：

(P1) 一个accepter 必须（注意是必须）接受它第一个收到的值，注意第一个收到的proposal值必须要接受，第二个可以不接受。

但这会导致一个问题，多个不同的proposer会提议不同的值，而这些不同的值可能会被不同的acceptor接受，而没有任何一个值达到半数。就算是两个值被提议，只要一个acceptor挂掉，也有可能导致没有一个值被多数的acceptor接受。所以acceptor必须允许接受多个提议的值。所以我们必须跟踪每一个可能被接受的提议（proposal）。用不同的数值标记不同的提议（proposal），这个编号是全局唯一的，不同的proposal有不同的编号。

所以，可以有多个proposal被chosen，但是请注意我们的目标是，只有一个value被chosen，多个proposal不要紧，只要多个proposal对应的值相同就可以。所以，这就是我们得到的第二个要求：

(P2)  如果一个值为v，标号为n的提议被选中（注意），那么所有被选择（注意）的序号大于n的提议的值都必须是v。

所以，编号可以不同，m对应proposal被选中之后，后被选中的proposal的值必须也是v。如何实现？

一个proposal要被选中，它必须先至少被一个acceptor接受吧，所以如果P2满足，充分条件是左右被acceptor的编号大于n的proposal的值必须是v。此时要求已经从新的proposal被选中，提前到proposal被接受，条件其实变强了。概括下就是下面这条：

(P2a) 如果一个值为v，标号为n的提议被选中（注意是选中），那么所有被接受（注意是接受）的序号大于n的提议的值都必须是v。 


(P2b) 如果一个值为v，标号为n的提议被选中（注意是选中），那么所有被发布（注意）的序号大于n的提议的值都必须是v。 



#### 基本机制

采用大多数机制（Majority）来保证2N+1的容错能力。即2N+1个节点的集群中最多允许N个节点出现个故障。

#### 目标

一个后者多个提交者提交提议，对多只让一个提议达成共识（是否包括不对任何提议达成共识？？？）。
