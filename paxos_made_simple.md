# 摘要

paxos算法是为了实现一种能容错的分布式系统，这是一种简单的并且显而易见的分布式算法。核心是共识算法：synod。

# 共识算法

## 问题

假设有一个进程集合，集合中的每个进程都可以提议一个值，一致性算法保证的是，只有一个值被选择。如果没有值被提议，那么没有value被选择。
如果有一个值被选择，那么进程应该能学习到这个值。针对共识的安全性需求是：

* （1）只有一个提议的值可能被选择，并且也只有一个值被选择。
* （2）一直值只有被确定选择之后，才能被其他进程学习到。

我们不会去指定精确的存活要求（不保证某些节点一直都在），但是我们需要保证某个提议值最终会被选择。并且被选择之后，进程可以学习到。
算法中，进程有三种角色的代理：proposers，accepters 和，learners。

注意，在具体实现中，一个进程会承担多个角色。

假设一个进程可以通过发送消息与另外一个进程通信。我们采用惯用的异步，非拜占庭模型，在这个模型中：

（1）进程以任意的速度运行，可能停止，可能重启。因为所有的角色都可能在一个值被选择之后停止，然后重启。 

（2） 消息的延时时不确定，也可能丢失，也可能乱序，可能重复，但是内容不会被损坏。

## 两个阶段

先选择一个值，然后学习到这个值。

## 选择一个值

最简单的选择一个值的办法是，只有一个accepter，proposer提议一个值，accepter选择第一个收到的提议的值。尽管简单，但是不满足要求，因为
accepter的故障挂机会导致后续的流程无法继续。（后续的流程是什么，学习值么？检测到挂了，可以再起一个新的，会有什么问题？）

我们选择另外一个方法，我们采用多个accepter，一个proposer给多个accepter发送提议，如果多个accepter接受这个值，那这个值就被接受，那么多个是几个？大于一半的数量，为什么？因为任何两个多数集合一定至少有一个公共成员，通过这个公共的成员，让集合中只存在一个多数接受的值。

比如9个节点，5个接受了值a，5个接受了值b，在一个节点只能接受一个值的前提下，a一定是等于b的。

在不考虑挂机以及消息丢失的情况下，如果我们希望就算只有一个值被提议，这个值也能被接受的话，就有如下要求：

(P1) 一个accepter 必须接受它第一个收到的值，注意第一个收到的proposal值必须要接受，第二个可以不接受。

但这会导致一个问题，多个而不同的proposer会提议不同的值，而这些不同的值可能会被不同的accepter接受，而没有任何一个值达到半数。就算是两个值被提议，只要一个accepter挂掉，也有可能导致没有一个值被多数的accepter接受。所以accepter必须允许接受多个提议的值。所以我们必须跟踪每一个可能被接受的提议。用不同的数值标记不同的提议（proposal）

(P2)  如果一个值为v，标号为m的提议被选择（注意），那么所有被选择（注意）的序号大于n的提议的值都必须是v。  
(P2a) 如果一个值为v，标号为m的提议被选择（注意），那么所有被接受（注意）的序号大于n的提议的值都必须是v。  
(P2b) 如果一个值为v，标号为m的提议被选择（注意），那么所有被发布（注意）的序号大于n的提议的值都必须是v。 


#### 基本机制

采用大多数机制（Majority）来保证2N+1的容错能力。即2N+1个节点的集群中最多允许N个节点出现个故障。

#### 目标

一个后者多个提交者提交提议，对多只让一个提议达成共识（是否包括不对任何提议达成共识？？？）。
