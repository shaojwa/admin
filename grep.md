#### 文件内容查找  

    grep <options> <pattern> <files>  

    示例：
    grep -rn "loosgood"  * 
    *  表示当前目录所有文件，也可以是某个文件名
    -r 是递归查找
    -n 是显示行号
    -R 查找所有文件包含子目录
    -i 忽略大小写
    -l 只列出匹配的文件名
    -L 列出不匹配的文件名， 
    -w 只匹配整个单词，而不是字符串的一部分

#### 查找man文档中以连字符开始的选项

    $ man chmod | grep [-]R
        -R, --recursive
 
#### 加上-n显示行号  
    
    $ man chmod | grep [-]R
    111:  -R, --recursive

#### 然后用more显示从某行开始
    
    $ man chmod | more +111
    
    
#### grep 递归行号

    grep -rn "loosgood"  * 
    egrep  -o '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+'
    *  表示当前目录所有文件，也可以是某个文件名
    -r 递归查找，不fllow 软链接
    -R 递归查找，fellow 软链接
    -w 只匹配整个单词，而不是字符串的一部分
    
 
如果想严格匹配某个单词（不是匹配字串），则需要添加边界判断，一般可以两种方式：

    -w 参数
    grep "\blog_file\b" or grep "\<log_file\>"
    
    这两种只会匹配log_file而不会匹配mon_cluster_log_file
    \<和\>是最常见的正则表达式的扩展，用来表示单词的开头和结尾，单词就是数字字母和下划线。
    \b和类似，但是可以同时代表\<和\>。也就是说\b的两侧必须一侧是单词字符一侧不是。
    而\B表示的是\B两侧必须都是单词字符。所以一般\B匹配的就是某个单词字符串的子串。

    \<，\>， \s，\w，\b这些很方便的表达都是GNU的扩展，而不是POSIX的标准。
    这些扩展一般的GNU版本常常会支持，但是需要确认，更多见《shell脚本学习指南》


#### grep 中的正则

最初的正则通配符是`. * ^ $ [] \ `。

-e 和 -E 功能不一样，-e 是为了可以指定多regex，并且为了支持以option开头的模式，本身用的还是BRE。而-E表示指定的是extended-regexp。

BRE中下面几个需要转义:`? + | ()`，而ERE中常见的正则特殊字符都不需要转义，所以简单点就用egrep或者grep -E。

下面的这个括号和管道默认都是要转义的：
```
ceph pg ls | grep "\(10\|15\|17\),\(10\|15\|17\),\(10\|15\|17\)"
ceph pg ls | grep -E "(10|15|17),(10|15|17),(10|15|17)" 
ceph pg ls | egrep   "(10|15|17),(10|15|17),(10|15|17)"
```

对于`{` 来说有点特殊，传统的egrep实现不把它当做meta-character，而有的实现想BRE一样，通过`\{`来实现元字符的功能。
所以兼容性的脚本中，应该避免用`{`来标示字面的左大括号（因为有的实现会把它当做元字符）。


GNU中的grep -E支持传统的用法，基于这个假设：如果`{`作为一个区间的起始字符并不合法的时候。比如命令`grep -E {1`,grep 就会搜索字串`{1`, 而不是报一个正则表达式语法错误。但这种用法对于考虑兼容性的脚本来说，需要避免。
