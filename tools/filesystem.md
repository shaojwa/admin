#### local file system

最初的unix文件系统和BSD中FastFileSystem中提供的接口和行为决定了后续文件系统的基本语义。最终形成POSIX标准。POSIX是绝大多数现代文件系统所遵守的。最早的磁盘，寻道相对与读取数据时很慢的（现在的磁盘也差不多），后续尽管寻道速度提高很多，但是磁盘读取速度的提升更快，所以相对磁盘读取速度，磁盘的定位延时反而更严重。所以精心设计数据在磁盘上的分布变得更加重要。现在日志结构文件系统（Log-structured File System ）就是为了避免定位延时而设计的。

#### client-server filesystem

典型如NFS和CIFS，中心化的架构是最大的问题，因为所有的文件系统操作都是在一台服务器上处理的。
在分布式环境中，网络文件系统会在一致性语义上有所放宽，来确保缓存的性能。比如，NFS的客户端异步回写数据给服务器，从不同客户端上同时访问这个文件可能不会一致得到最新的数据拷贝。类似的，客户端会缓存元数据并使用固定的一段时间，以限制客户端和服务器之间的交互进而从服务器端加载。这种数据一致性上要求的放宽，会在多应用场景下发生问题，这使得多应用场景放弃使用NFS环境。

#### distributed filse systems

早期的分布式文件系统中，比如AFS，Coda，以及Sprite，使用中心服务器去协调文件系统访问，发放lease来显示承诺数据或者元数据的可用性，用以客户端缓存一段特定的时间。后续的回调可以通过访问冲突来撤销之前的承诺。然后，当发生write sharing事件时，Sprite简单的禁止缓存。而AFS采用了一种其他的一致性模型，通过文件的open和close而不是独立的read 和write 来进行限制。而NFS（4.0之前的版本，通过加入类似lease的限制实现）则是无状态的，当文件共享会牺牲一致性。
AFS和Sprite，在分区边界上都是可见的，因为都缺乏link和原子 rename的支持。比较而言，ceph提供的是统一的文件系统命名空间，以及完全一致的POSIX语法。


#### journal

xfs会在磁盘上维护一个journal，用来记录元数据的更新。如果有错误发生，journal可以被读取来确保更新成功且正确应用，或者清理掉部分被应用的更新。
journal会带来部分性能的损耗。磁盘需要频繁定位并追加到日志，每一次的元数据更新都要被写两次。但是他避免了进行错误恢复时可能需要的更加耗时的一致性校验操作。
